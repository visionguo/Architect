# 数据结构
https://github.com/xingshaocheng/architect-awesome


## 队列
java队列 - queue
Queue：一个队列就是一个先入先出（FIFO）的数据结构
Queue接口与List、Set同一级别，继承了Collection接口，LinkedList实现了Deque接口

非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制(compareAndSwapObject原子操作)
阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue(无界)、DelayQueue、PriorityBlockingQueue，采用锁机制；使用ReentrantLock锁

示例：
package com.yao;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class BlockingQueueTest {
 /**
 定义装苹果的篮子
  */
 public static class Basket{
  // 篮子，能够容纳3个苹果
  BlockingQueue<String> basket = new ArrayBlockingQueue<String>(3);

  // 生产苹果，放入篮子
  public void produce() throws InterruptedException{
   // put方法放入一个苹果，若basket满了，等到basket有位置
   basket.put("An apple");
  }
  // 消费苹果，从篮子中取走
  public String consume() throws InterruptedException{
   // get方法取出一个苹果，若basket为空，等到basket有苹果为止
   String apple = basket.take();
   return apple;
  }

  public int getAppleNumber(){
   return basket.size();
  }

 }
 //　测试方法
 public static void testBasket() {
  // 建立一个装苹果的篮子
  final Basket basket = new Basket();
  // 定义苹果生产者
  class Producer implements Runnable {
   public void run() {
    try {
     while (true) {
      // 生产苹果
      System.out.println("生产者准备生产苹果：" 
        + System.currentTimeMillis());
      basket.produce();
      System.out.println("生产者生产苹果完毕：" 
        + System.currentTimeMillis());
      System.out.println("生产完后有苹果："+basket.getAppleNumber()+"个");
      // 休眠300ms
      Thread.sleep(300);
     }
    } catch (InterruptedException ex) {
    }
   }
  }
  // 定义苹果消费者
  class Consumer implements Runnable {
   public void run() {
    try {
     while (true) {
      // 消费苹果
      System.out.println("消费者准备消费苹果：" 
        + System.currentTimeMillis());
      basket.consume();
      System.out.println("消费者消费苹果完毕：" 
        + System.currentTimeMillis());
      System.out.println("消费完后有苹果："+basket.getAppleNumber()+"个");
      // 休眠1000ms
      Thread.sleep(1000);
     }
    } catch (InterruptedException ex) {
    }
   }
  }

  ExecutorService service = Executors.newCachedThreadPool();
  Producer producer = new Producer();
  Consumer consumer = new Consumer();
  service.submit(producer);
  service.submit(consumer);
  // 程序运行10s后，所有任务停止
  try {
   Thread.sleep(10000);
  } catch (InterruptedException e) {
  }
  service.shutdownNow();
 }
 public static void main(String[] args) {
  BlockingQueueTest.testBasket();
 }
}

## 集合
### Set：用于存储无序元素，值不能重复
### HashSet：不存入重复元素的规则，使用hashcode和equals
元素的哈希值通过元素的hashcode方法来获取，hashset首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法，如果equals结果为true，hashset就视为同一个元素，如果equals 为false就不是同一个元素
哈希值相同，但equals为false的元素如何存储，方法是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中），总结下就是哈希一样的存一列
### TreeSet：
1、元素自身具备比较性，元素需要实现Comparable接口，覆盖compareTo方法
2、容器具备比较性，当元素自身不具备比较性，或者元素自身具备的比较性不是所需的，只能让容器自身具备
定义一个类实现 Comparator接口，覆盖compare方法，并将该接口的子类对象作为参数传递给 TreeSet集合的构造函数
当Comparable和Comparator比较方式同时存在，以Comparator比较方式为主。
通过 return 0来判断唯一性
### LinkedHashSet：会保存插入的顺序

总结：
看到array，就要想到角标
看到link，就要想到first、last
看到hash，就要想到hashCode、equals
看到tree，就要想到两个接口，Comparable、Comparator
 
## 链表、数组
![image](https://user-images.githubusercontent.com/30895025/205802631-b6b2874f-160b-4baa-aceb-4a8f4a3f2e08.png)

List分为3类：ArrayList、LinkedList和Vector
1、是按顺序查找
2、允许存储项为空
3、允许多个存储项的值相等
 
### List
继承于Collection接口，除了Collection通用的方法以外，扩展了部分只属于List的方法
### ArraryList
是一个数组实现的列表，由于数据是存入数组中的，和数组的特点一致，查询很快，查询返回数组下标对应的值即可，适用于多查找的场景，但中间部分的插入和删除很慢，
### Vector
是ArrayList的线程安全版，方法前都加了synchronized锁，其它实现逻辑都相同，如果对线程安全要求不高的话，可以选择ArrayList，毕竟synchronized很耗性能。
### LinkedList
由链表实现，插入和删除方便，适用于多次数据替换的场景，双向链表，LinkedList继承于AbstractSequentialList，和ArrayList一个套路，内部维护了3个成员变量，一个是当前链表的头节点，一个是尾部节点，还有链表长度
 
## 字典、关联数组
### HashMap：
最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，HashMap最多只允许一条记录的键为Null（多条会覆盖），允许多条记录的值为Null，非同步的
### TreeMap：
能够把它保存的记录根据键（key）排序，默认是按升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的，TreeMap不允许key的值为null，非同步的
### LinkedHashMap：
保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，key和value均允许为空，非同步的

## 栈
1、Stack是线程安全的
2、内部使用数组保存数据，不够时翻倍
 
栈是一种用于存储数据的简单数据结构，类似链表或者顺序表（俗称线性表），栈是一种特殊的线性表，其插入和删除操作只允许在线性表的一端进行，把允许操作的一端称为栈顶（Top）,不可操作的一端称为栈底（Bottom）,同时把插入元素的操作称为入栈（Push），删除元素的操作称为出栈（Pop），若栈中没有任何元素，则称为空栈。 

## 树
### 二叉树
每个节点最多有两个叶子节点
二叉树由节点和边组成，节点分为根节点、父节点和子节点
![image](https://user-images.githubusercontent.com/30895025/205842683-d5a11ee6-c7e5-4436-bf31-6d93e6836d19.png)
红色是根节点（root），蓝色是子节点也是父节点，绿色是子节点，其余的线是边，节点和链表中的节点一样都可以存放数据信息，树中的边可以用自引用表示，这种引用就是c/c++里面的指针，通常来说树是顶部小，底部大，且树呈分层结构，root节点是第0层，以此类推，二叉树最多有两个节点。
二叉树搜索：二叉树一个节点左子节点的关键字小于这个节点，右子节点关键字大于或等于这个父节点。
查找关键字：在有序数组中通过二分排序效率非常高。
树的最值查找：从root开始查找，最小值只会出现所有父节点的左节点处，最大值只会出现在所有父节点的沿着右节点搜索的最底层右节点处。
 

### 完全二叉树
叶节点只能出现在最下层和次下层，并且最小面一层的结点都集中在该层最左边的若干位置的二叉树。
![image](https://user-images.githubusercontent.com/30895025/205850376-ce47795d-6719-4b21-9406-3a11be65d4c8.png)
一颗深度为k的有n个结点的二叉树，对树中的结点按从上至下，从左到右的顺序进行编号，如果编号为i（1<=i<=n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这颗二叉树称为完全二叉树。
 
### 平衡二叉树
左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。如果插入或者删除一个节点使的高度之差大于1，就要进行节点之间的旋转，将二叉树重新维持在一个平衡状态，这个方案解决了二叉查找树退化成链表的问题，把插入、查找、删除的时间复杂度最好情况和最坏情况都维持在O(logN)，但频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。
![image](https://user-images.githubusercontent.com/30895025/205857681-439d1e4f-e79a-44ae-93f6-4f8e2ae411e9.png)


### 二叉查找树(BST)

