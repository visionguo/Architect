# 数据结构
https://github.com/xingshaocheng/architect-awesome


## 队列
java队列 - queue
Queue：一个队列就是一个先入先出（FIFO）的数据结构
Queue接口与List、Set同一级别，继承了Collection接口，LinkedList实现了Deque接口

非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制(compareAndSwapObject原子操作)
阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue(无界)、DelayQueue、PriorityBlockingQueue，采用锁机制；使用ReentrantLock锁

示例：
package com.yao;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class BlockingQueueTest {
 /**
 定义装苹果的篮子
  */
 public static class Basket{
  // 篮子，能够容纳3个苹果
  BlockingQueue<String> basket = new ArrayBlockingQueue<String>(3);

  // 生产苹果，放入篮子
  public void produce() throws InterruptedException{
   // put方法放入一个苹果，若basket满了，等到basket有位置
   basket.put("An apple");
  }
  // 消费苹果，从篮子中取走
  public String consume() throws InterruptedException{
   // get方法取出一个苹果，若basket为空，等到basket有苹果为止
   String apple = basket.take();
   return apple;
  }

  public int getAppleNumber(){
   return basket.size();
  }

 }
 //　测试方法
 public static void testBasket() {
  // 建立一个装苹果的篮子
  final Basket basket = new Basket();
  // 定义苹果生产者
  class Producer implements Runnable {
   public void run() {
    try {
     while (true) {
      // 生产苹果
      System.out.println("生产者准备生产苹果：" 
        + System.currentTimeMillis());
      basket.produce();
      System.out.println("生产者生产苹果完毕：" 
        + System.currentTimeMillis());
      System.out.println("生产完后有苹果："+basket.getAppleNumber()+"个");
      // 休眠300ms
      Thread.sleep(300);
     }
    } catch (InterruptedException ex) {
    }
   }
  }
  // 定义苹果消费者
  class Consumer implements Runnable {
   public void run() {
    try {
     while (true) {
      // 消费苹果
      System.out.println("消费者准备消费苹果：" 
        + System.currentTimeMillis());
      basket.consume();
      System.out.println("消费者消费苹果完毕：" 
        + System.currentTimeMillis());
      System.out.println("消费完后有苹果："+basket.getAppleNumber()+"个");
      // 休眠1000ms
      Thread.sleep(1000);
     }
    } catch (InterruptedException ex) {
    }
   }
  }

  ExecutorService service = Executors.newCachedThreadPool();
  Producer producer = new Producer();
  Consumer consumer = new Consumer();
  service.submit(producer);
  service.submit(consumer);
  // 程序运行10s后，所有任务停止
  try {
   Thread.sleep(10000);
  } catch (InterruptedException e) {
  }
  service.shutdownNow();
 }
 public static void main(String[] args) {
  BlockingQueueTest.testBasket();
 }
}

## 集合
### Set：用于存储无序元素，值不能重复
### HashSet：不存入重复元素的规则，使用hashcode和equals
元素的哈希值通过元素的hashcode方法来获取，hashset首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法，如果equals结果为true，hashset就视为同一个元素，如果equals 为false就不是同一个元素
哈希值相同，但equals为false的元素如何存储，方法是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中），总结下就是哈希一样的存一列
### TreeSet：
1、元素自身具备比较性，元素需要实现Comparable接口，覆盖compareTo方法
2、容器具备比较性，当元素自身不具备比较性，或者元素自身具备的比较性不是所需的，只能让容器自身具备
定义一个类实现 Comparator接口，覆盖compare方法，并将该接口的子类对象作为参数传递给 TreeSet集合的构造函数
当Comparable和Comparator比较方式同时存在，以Comparator比较方式为主。
通过 return 0来判断唯一性
### LinkedHashSet：会保存插入的顺序

总结：
看到array，就要想到角标
看到link，就要想到first、last
看到hash，就要想到hashCode、equals
看到tree，就要想到两个接口，Comparable、Comparator
 
## 链表、数组
![image](https://user-images.githubusercontent.com/30895025/205802631-b6b2874f-160b-4baa-aceb-4a8f4a3f2e08.png)

List分为3类：ArrayList、LinkedList和Vector
1、是按顺序查找
2、允许存储项为空
3、允许多个存储项的值相等

## 字典、关联数组

## 栈
1、Stack是线程安全的
2、内部使用数组保存数据，不够时翻倍

## 树
二叉树
每个节点最多有两个叶子节点
二叉树由节点和边组成，节点分为根节点、父节点和子节点

完全二叉树
平衡二叉树
二叉查找树(BST)

