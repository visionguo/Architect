# 算法
## 排序算法
内排序:在排序过程中，全部记录存放在内存\
外排序：排序过程中需要使用外存\

内排序\
1、插入排序：直接插入排序、二分法插入排序、希尔排序\
2、选择排序：直接选择排序、堆排序\
3、交换排序：冒泡排序、快速排序\
4、归并排序\
5、基数排序\

![image](https://user-images.githubusercontent.com/30895025/207545506-93f14fde-bd45-4731-99e0-4727bac1a790.png)

## 选择排序
每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。\
每一趟在n-i+1(i=1,2,...n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录，基于此思路的算法主要有简单选择排序、树型选择排序和堆排序。\

### 简单选择排序：
给定数组：int[] arr={里面n个数据}；\
第1趟排序，在待排序数据arr[1] ~ arr[n]中选出最小的数据，将它与arr[1]交换；\
第2趟，在待排序数据arr[2] ~ arr[n]中选出最小的数据，将它与r[2]交换；\
以此类推，第i趟在待排序数据arr[i] ~ arr[n]中选出最小的数据，将它与r[i]交换，直到全部排序完成。\

选择排序的时间复杂度：简单选择排序的比较次数与序列的初始排序无关。\
假设待排序的序列有N个元素，则比较次数永远都是N（N-1）/2。而移动次数与序列的初始排序有关。\
当序列正序时，移动次数最少，为0，当序列反序时，移动次数最多，为3N（N-1）/2\
所以，综上，简单排序的时间复杂度为O(N**2)\

### 直接选择排序
在要排序的一组数中，选出最小的一个数与第一个位置的数交换；\
然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。\


## 冒泡排序
在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。\
即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\
![image](https://user-images.githubusercontent.com/30895025/207590479-9f1bcb4a-513c-476e-a23c-8370863ddbf1.png)

## 插入排序
每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置，直到全部插入排序完位置。\
关键问题：在前面已经排好序的序列中找到合适的插入位置\

### 直接插入排序：
从后向前找到合适位置后插入\
每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止\

### 二分法插入排序
按二分法找到合适位置插入\
和直接插入思想一样，只是找合适的插入位置的方式不同，按二分法找到合适的位置，可以减少比较的次数。\


## 快速排序
选择一个基准元素，通常选择第一个元素或最后一个元素，通过一趟扫描，将待排序列分成两部分，
一部分比基准元素小，一部分大于等于基准元素，此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。\

## 归并排序
归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的，
然后再把有序子序列合并为整体有序序列。\
![image](https://user-images.githubusercontent.com/30895025/207598871-e0234469-ca58-4a40-ad7b-60a793bac3b4.png)

## 堆排序
排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。\
堆排序是一种树形选择排序，是对直接选择排序的有效改进。\
堆定义：具有n个元素的序列（h1,h2,...,hn），当且仅当满足（hi>=h2i,hi>=2i+1）或（hi<=h2i,hi<=2i+1）(i=1,2,...,n/2)时称之为堆。\
由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。\
思想：初始时把要排序的数的序列看作是一颗顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面（n-1）个数重新调整使之成为堆。依次类推，直到只有两个节点的堆，并对他们作交换，最后得到有n个节点的有序序列，从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序由两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。\
初始序列：46,79,56,38,40,84\
建堆：

![image](https://user-images.githubusercontent.com/30895025/207603593-26a61af1-19e3-4e48-9f42-f2b1bb336688.png)

交换，从堆中踢出最大数：\

![image](https://user-images.githubusercontent.com/30895025/207603885-5bcfcfc3-af8f-49b6-bd1f-ab910c1757ca.png)

## 计数排序
输入一个数X，确定小于X的元素的个数，这样就可以把这个数放在输出数组的指定位置上。\
假设输入数组是A[1...n]，则需要一个辅助数组C[O...K]，一个输出数组B[1...n]。其中K代表输入数组中的最大值，n代表输入数组的长度。\
其中，输入数组A是需要进行排序的一组数据，输出数组B是需要排序完成后的数据。辅助数组中是按键值存储该键值在输入数组中出现的次数。\

思路：\
1、初始化辅助数组；\
2、循环遍历每一个输入元素，如果一个输入元素为i，则辅助数组中相应的C[i]的值加1。执行完毕之后。数组C中存储的就是各个键值在输入数组中出现的次数。\
3、再通过加总结算确定对于从1到k，有多少个输入元素是小于等于k的。将结果赋值到数组C中。\
4、
循环将A[J]放到它在输出数组的正确位置上。对于一个值来说，C[A[J]]的值就是它在输出数组B中的正确位置。\
当输入数组中的元素都是互异时，就比较好理解，但是当数组中有些元素相同时。\
我们每将一个值放入输出数组中，都要将辅助数组中相应的值减1，这样，当存在下一个相同的值时，该元素可直接放在输出数组中相应的位置上。\
总结：计数排序的时间复杂度为O(n)，计数排序最重要的特性是稳定。\
缺点：计数排序非常浪费空间。例如需要排序数的范围是0~2100000000之间，那你则需要申请2100000001个变量。\

## 桶排序
桶排序的时间复杂度为O(n)，计数排序是假设输入的数据都属于一个小区间内的证书，而桶排序则假设输入是由一个随机过程产生的。
该过程将元素均匀、独立的分布在区间（0，1）上。\
桶排序的基本思路：\
1、输入数组为A，辅助数组为B，初始化数组B，可将（0，1）按指定大小分为N个区间，即数组中有N个元素，称为桶。\
2、循环遍历输入数组，将A数组中大小位于某一区间的数存放在指定的B数组元素维护的链表上。
B数组上的元素维护一个链表。链表上的元素是位于区间大小的A数组元素。\
3、完成上述操作之后，将B数组中每个元素维护的链表进行排序。\
4、最后按照B数组中元素的顺序输出，B[0] -> B[1] -> ... B[N-1]




