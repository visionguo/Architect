#排序算法

内排序:在排序过程中，全部记录存放在内存
外排序：排序过程中需要使用外存

内排序
1、插入排序：直接插入排序、二分法插入排序、希尔排序
2、选择排序：直接选择排序、堆排序
3、交换排序：冒泡排序、快速排序
4、归并排序
5、基数排序

![image](https://user-images.githubusercontent.com/30895025/207545506-93f14fde-bd45-4731-99e0-4727bac1a790.png)

##选择排序

每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。
每一趟在n-i+1(i=1,2,...n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录，基于此思路的算法主要有简单选择排序、树型选择排序和堆排序

简单选择排序基本思想：

给定数组：int[] arr={里面n个数据}；
第1趟排序，在待排序数据arr[1] ~ arr[n]中选出最小的数据，将它与arr[1]交换；
第2趟，在待排序数据arr[2] ~ arr[n]中选出最小的数据，将它与r[2]交换；
以此类推，第i趟在待排序数据arr[i] ~ arr[n]中选出最小的数据，将它与r[i]交换，直到全部排序完成。

选择排序的时间复杂度：简单选择排序的比较次数与序列的初始排序无关。
假设待排序的序列有N个元素，则比较次数永远都是N（N-1）/2。而移动次数与序列的初始排序有关。
当序列正序时，移动次数最少，为0，当序列反序时，移动次数最多，为3N（N-1）/2
所以，综上，简单排序的时间复杂度为O(N**2)

直接选择排序
在要排序的一组数中，选出最小的一个数与第一个位置的数交换；
然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。


##冒泡排序
在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。
即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。
![image](https://user-images.githubusercontent.com/30895025/207590479-9f1bcb4a-513c-476e-a23c-8370863ddbf1.png)
