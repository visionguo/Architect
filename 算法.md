# 算法
## 排序算法
内排序:在排序过程中，全部记录存放在内存\
外排序：排序过程中需要使用外存\

内排序\
1、插入排序：直接插入排序、二分法插入排序、希尔排序\
2、选择排序：直接选择排序、堆排序\
3、交换排序：冒泡排序、快速排序\
4、归并排序\
5、基数排序\

![image](https://user-images.githubusercontent.com/30895025/207545506-93f14fde-bd45-4731-99e0-4727bac1a790.png)

## 选择排序
每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。\
每一趟在n-i+1(i=1,2,...n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录，基于此思路的算法主要有简单选择排序、树型选择排序和堆排序。\

### 简单选择排序：
给定数组：int[] arr={里面n个数据}；\
第1趟排序，在待排序数据arr[1] ~ arr[n]中选出最小的数据，将它与arr[1]交换；\
第2趟，在待排序数据arr[2] ~ arr[n]中选出最小的数据，将它与r[2]交换；\
以此类推，第i趟在待排序数据arr[i] ~ arr[n]中选出最小的数据，将它与r[i]交换，直到全部排序完成。\

选择排序的时间复杂度：简单选择排序的比较次数与序列的初始排序无关。\
假设待排序的序列有N个元素，则比较次数永远都是N（N-1）/2。而移动次数与序列的初始排序有关。\
当序列正序时，移动次数最少，为0，当序列反序时，移动次数最多，为3N（N-1）/2\
所以，综上，简单排序的时间复杂度为O(N**2)\

### 直接选择排序
在要排序的一组数中，选出最小的一个数与第一个位置的数交换；\
然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。\


## 冒泡排序
在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。\
即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。\
![image](https://user-images.githubusercontent.com/30895025/207590479-9f1bcb4a-513c-476e-a23c-8370863ddbf1.png)

## 插入排序
每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置，直到全部插入排序完位置。\
关键问题：在前面已经排好序的序列中找到合适的插入位置\

### 直接插入排序：
从后向前找到合适位置后插入\
每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止\

### 二分法插入排序
按二分法找到合适位置插入\
和直接插入思想一样，只是找合适的插入位置的方式不同，按二分法找到合适的位置，可以减少比较的次数。\

## 快速排序
选择一个基准元素，通常选择第一个元素或最后一个元素，通过一趟扫描，将待排序列分成两部分，
一部分比基准元素小，一部分大于等于基准元素，此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。\

## 归并排序
归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的，
然后再把有序子序列合并为整体有序序列。\
![image](https://user-images.githubusercontent.com/30895025/207598871-e0234469-ca58-4a40-ad7b-60a793bac3b4.png)

## 堆排序
排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。\
堆排序是一种树形选择排序，是对直接选择排序的有效改进。\
堆定义：具有n个元素的序列（h1,h2,...,hn），当且仅当满足（hi>=h2i,hi>=2i+1）或（hi<=h2i,hi<=2i+1）(i=1,2,...,n/2)时称之为堆。\
由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。
思想：初始时把要排序的数的序列看作是一颗顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面（n-1）个数重新调整使之成为堆。依次类推，直到只有两个节点的堆，并对他们作交换，最后得到有n个节点的有序序列，从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序由两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。
初始序列：46,79,56,38,40,84
建堆：
![image](https://user-images.githubusercontent.com/30895025/207603593-26a61af1-19e3-4e48-9f42-f2b1bb336688.png)
交换，从堆中踢出最大数
![image](https://user-images.githubusercontent.com/30895025/207603885-5bcfcfc3-af8f-49b6-bd1f-ab910c1757ca.png)






